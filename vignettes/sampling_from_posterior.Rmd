---
title: "Sampling From Posterior"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{sampling_from_posterior}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7
)
library(tidyverse)
library(glue)
library(sbmR)
```

```{r, eval = FALSE}
library(sbmR)
library(glue)
library(tidyverse)
```


In this document we will explore how to use the function `mcmc_sweep()` to sample from the posterior of a simulated network and investigate the results of doing so. 


## Setting up network structure

First we will generate our simulated network. First we set a seed to make the structure reproducable and then we draw our random network using the `sim_basic_block_network()` function to draw from a network with 3 groups and 40 nodes per group. 

```{r}
set.seed(312)

n_blocks <- 4    # Total number of blocks
block_size <- 75 # How many nodes in each block

network <- sim_basic_block_network(
  n_blocks = n_blocks,     
  n_nodes_per_block = block_size,  
  return_edge_propensities = TRUE
)
```


First we can make sure our edge propensities look reasonable 

```{r}
network$edge_propensities %>% 
  ggplot(aes(x = block_1, y = block_2)) +
  geom_tile(aes(fill = propensity)) +
  theme_minimal()
```


Next, we can visualize the actual drawn network. 

```{r}
visualize_network(network, width = '100%')
```

We can see a decent amount of separation with perhaps more cohesion between the green and blue nodes than the orange


## Setting up SBM

Now that we have our data we can load it into an SBM object and look at the first few nodes worth of summary. 

```{r}
my_sbm <- create_sbm(network)

my_sbm %>% get_state() %>% head()
```


### Initializing the chain location

In an attempt to set our initial chain location to an optimal position we will agglomeratively merge the network using the collapse groups function. This will return a list of results for different model sizes. 

```{r}
collapse_results <- my_sbm %>%
  collapse_blocks(report_all_steps = TRUE, sigma = 1.1)
```


```{r}
visualize_collapse_results(collapse_results, heuristic = 'dev_from_rolling_mean') +
  geom_vline(xintercept = n_blocks, color = 'orangered') +
  xlim(0,20)
```


So we can use the helper function `choose_best_collapse_state()` to scan through the results and find the optimal partitioning based upon the designated hueristic. The plot above is showing the score from the heuristic where the best collapse is determined by deviation from rolling mean (lower plot). Any scoring function can be provided as long as it takes as an argument the entropy column and or number of blocks column and returns a vector of scores where the highest value is the break to choosen. 

Right now we will stick with the deviation from rolling mean to choose the best number of blocks. 

```{r}
my_sbm <- choose_best_collapse_state(my_sbm, collapse_results, heuristic = "dev_from_rolling_mean", verbose = TRUE)
```

### Visualizing these results. 

We can investigate the structure of this chosen partitioning against the true structure that we simulated using `visualize_network()`...

```{r extract_infered_blocks}
merged_state <- my_sbm %>% 
  get_state() %>% 
  select(id, parent)

nodes_w_inferred_block <- network$nodes  %>%
  left_join(merged_state, by = 'id') %>% 
  rename(inferred = parent)

table(nodes_w_inferred_block$inferred,nodes_w_inferred_block$block)
```

So we already have a perfect separation into the `r n_blocks` blocks. This should be a good starting place for our sampling.


## Sampling from the posterior

Now that we have our model in a starting place hopefully close to the median of the posterior we can initiate the MCMC sampling. We will start by doing a few sweeps to see if our model shape has stabalized at all. 

```{r}
num_sweeps <- 20

sweep_results <- mcmc_sweep(my_sbm, num_sweeps = num_sweeps, eps = 0.1, track_pairs = FALSE)

sweep_df <- sweep_results$sweep_info %>% 
  mutate(sweep = 1:n(),
         label = 'eps = 0.1') %>% 
  pivot_longer(entropy_delta:num_nodes_moved)

plot_sweep_results <- function(sweep_results_df){
   sweep_results_df %>% 
    ggplot(aes(x = sweep, y = value)) +
    geom_line() +
    facet_grid(name~., scales = "free_y")
}

plot_sweep_results(sweep_df) +
  labs(
    title = glue::glue('Result of {num_sweeps} MCMC sweeps'),
    subtitle = "Entropy Delta of sweep and number of nodes moved for sweep"
  )
```

So we get almost no movement at all, indicating the model has stuck into a local (in this case the global) minimum. 

We can force it to explore a bit more by upping the epsilon value for the model. 

```{r}
num_sweeps <- 20

sweep_results <- mcmc_sweep(my_sbm, num_sweeps = num_sweeps, eps = 4, track_pairs = FALSE)

sweep_df <- sweep_results$sweep_info %>% 
  mutate(sweep = 1:n(),
         label = 'eps = 1') %>% 
  pivot_longer(entropy_delta:num_nodes_moved)


plot_sweep_results(sweep_df) +
  labs(
    title = glue::glue('Result of {num_sweeps} MCMC sweeps'),
    subtitle = "Entropy Delta of sweep and number of nodes moved for sweep"
  )

```


```{r}
nodes_w_inferred_block <- my_sbm %>% 
  get_state() %>% 
  select(id, parent) %>% 
  right_join(network$nodes, by = 'id') %>% 
  rename(inferred = parent)

table(nodes_w_inferred_block$inferred,nodes_w_inferred_block$block)
```

This increased epsilon value resulted mostly in some small groups being split of of the larger ones. A thing to note however, even though we have more groups than we should, never have an infered group that spans more than a single true group. 

### Comparing different epsilons

Let's run 50 sweeps for a few different epsilon values and see how the traces compare. 

```{r}
# Function to run n sweeps from a freshly initialized model
run_sweeps_at_eps <- function(eps, num_sweeps = 50){
  # Load a fresh sbm right after collapsing initialization
  fresh_sbm <- choose_best_collapse_state(my_sbm, collapse_results, heuristic = "dev_from_rolling_mean")
  
  # Run sweeps at given epsilon value and return results
  mcmc_sweep(fresh_sbm, num_sweeps = num_sweeps, eps = eps)$sweep_info %>% 
    mutate(sweep = 1:n(),
           eps = eps,
           label = glue::glue('eps = {eps}')) %>% 
    pivot_longer(entropy_delta:num_nodes_moved)
}

all_eps_results <- seq(from = 0.1, to = 10, length.out = 4) %>% 
  map_dfr(run_sweeps_at_eps)

all_eps_results %>% 
  filter(name == 'entropy_delta') %>% 
  mutate(label = forcats::fct_inorder(as.factor(label))) %>% 
  ggplot(aes(x = sweep, y = value)) +
  geom_line() +
  facet_grid(label~.)
```

As expected the lines get less stable as epsilon increases. 

## Pairwise block consensus

The `mcmc_sweep()` method has an option to keep track of how connected each node is with all other nodes. The idea being that the more frequently that two nodes are in the same block together, the more confident the model is that they are truly connected. We can visualize this by accessing the `pairing_counts` dataframe attached to the outputs of `mcmc_sweep()` with `track_pairs = TRUE`.


First we will run one hundred sweeps for nodes with epsilon set to 0.5. 

```{r}
sweep_results <- my_sbm %>%
  choose_best_collapse_state( collapse_results, heuristic = "dev_from_rolling_mean") %>% 
  mcmc_sweep(num_sweeps = 100, eps = 0.5, track_pairs = TRUE)
```

Then we can look at the supplied `pairing_counts` dataframe to see how often pairwise nodes are connected to eachother. 

```{r}
sweep_results$pairing_counts %>% 
  ggplot(aes(x = node_a, y = node_b, fill = proportion_connected)) +
  geom_raster() +
  theme(
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  labs(x = "node a", 
       y = "node b",
       fill = "Proportion of sweeps\nin same block",
       title = "Node block consensus matrix",
       subtitle = glue::glue("True number of blocks: {n_blocks}"))
```

Another method to investigate these block concensus results is to look at the ECDF of the node connection probabilities. 

A good behavior indicating there are strong clusters in your data is an ECDF that has a large flat section in the middle, indicating that almost all of your node connection propensities are close to zero or close to one. We can look at this for our mcmc results as well. 

```{r}
sweep_results$pairing_counts %>% 
  ggplot(aes(x = proportion_connected)) +
  stat_ecdf() +
  ggtitle("Pairwise block concensus proportion distribution")
```

So we see a very strong flat line from zero all the way to a small bump at around 0.65 and then again a sharp bump right at one. This indicates that a few nodes sometimes split off into other groups. 

A last way of looking at this is to create a new network from our data. This time drawing an edge between two nodes if their pairwise connection probability was above some threshold. Once we have this network we can plot it and see if isolated subgraphs appear in the network. Deciding any threshold is fraught with danger, but if we keep it small we should be in the clear. Let's do that with our results...



```{r}
edges <- pairwise_connections %>% 
  filter(proportion_connected > 0.6) %>% 
  select(from = node_a, to = node_b)

nodes <- edges %>% 
  pivot_longer(c(from, to), values_to="id") %>% 
  distinct(id) %>% 
  mutate(block = str_remove(id, "_[0-9]*"))

visualize_network(edges, nodes)
```

So we can see that we have perfect separation into our true groups. 
